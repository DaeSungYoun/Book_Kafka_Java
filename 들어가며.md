# 1. 들어가며
## 1.1 카프카의 탄생
## 1.2 빅데이터 파이프라인에서 카프카의 역할
* 높은 처리량
    * 카프카는 프로듀서가 브로커로 데이터를 보낼 때와 컨슈머가 브로커로부터 데이터를 받을 때 모두 묶어서 전송
    * 많은 양의 데이터를 묶음 단위로 처리하는 배치로 빠르게 처리할 수 있기 때문에 대용량의 실시간 로그데이터를 처리하는 데에 적합
    * 파티션 단위를 통해 동일 목적의 데이터를 여러 파티션에 분배하고 데이터를 병렬 처리 할 수 있다.
    * 파티션 개수만큼 컨슈머 개수를 늘려 동일 시간당 데이터 처리량을 늘릴 수 있다.
* 확장성
    * 카프카는 가변적인 환경에서 안정적으로 확장 가능하도록 설계되었다.
    * 스케일 아웃, 스케일 인 가능
* 영속성
    * 다른 메시징 플랫폼과 다르게 전송받은 데이터를 메모리에 저장하지 않고 파일 시스템에 저장
    * 운영체제에서는 파일 I/O 성능 향상을 위해 페이지 캐시 영역을 메모리에 따로 생성하여 사용
    * 페이지 캐시 메모리 영역으로 파일 시스템에 저장하고 데이터를 저장, 전송하더라도 처리량이 높음
    * 디스크 기반의 파일 시스템을 활용한 덕분에 브로커 애플리케이션이 장애 발생으로 인해 급작스럽게 종료되더라도 프로세스를 재시작하여 안전하게 데이터를 다시 처리 할 수 있다.
* 고가용성
    * 3개 이상의 서버들로 운영되는 카프카 클러스터는 일부 서버에 장애가 발생하더라도 무중단으로 안전하고 지속적으로 데이터를 처리 할 수 있다.
    * 클러스터로 이루어진 카프카는 데이터의 복제(replication)를 통해 고가용성의 특징을 가지게 되었다.
    * 프로듀서로 전송ㅂㄷ은 데이터를 모든 브로커에 저장하여 한 브로커에 장애가 발생하더라도 복제된 데이터가 나머지 브로커에 저장되어 있으므로 데이터 처리 가능
      
    > 카프카 클러스터를 1대, 2대가 아닌 3대 이상의 브로커들로 구성해야 하는 이유<br><br>
    유실을 막기 위해서 min.insync.replicas 옵션을 사용할 수 있다.<br>
    min.insync.replicas 옵션을 2로 설정하면 최소 2개 이상의 브로커에 데이터가 완전 복제됨을 보장한다.<br>
    이 옵션을 2로 사용할 때는 브로커를 3대 이상 운영해야만 한다. 왜냐하면 3개 중 1개의 브로커에 장애가 나더라도 지속적으로 데이터를 처리할 수 있기 떄문이다<br>
    min.insync.replicas 옵션값보다 작은 수의 브로커가 존재할 때는 토픽에 더는 데이터를 넣을 수 없다. <br>
    그렇기 때문에 상용에서 카프카를 운영할 때는 3대 이상의 브로커로 클러스터를 구축해야 한다.

## 1.3 데이터 레이크 아키텍처와 카프카의 미래
* 데이터 레이크 아키텍처
    * 람다 아키텍처(lambda architecture)
        * 배치 레이어, 서빙 레이어, 스피드 레이어로 구성됨
    * 카파 아키텍처(kappa architecture)
## 1.4 정리
* 카프카는 오픈소스 생태계 속에서 지속적으로 발전하고 있다.
* 기본 기능인 컨슈머, 프로듀서, 커넥트, 스트림즈 뿐만아니라 ksqlDB, rest proxy, burrow 등 다양한 툴들과 커넥터들이 카프카와 연동되어 활용도가 높아지고 있다.
* 카프카를 활용할 수 있는 방안은 아키텍처를 어떻게 구성하느냐에 따라 무궁무진하게 많아진다.